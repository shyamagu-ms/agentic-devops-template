---
description: "Svelte/SvelteKit (静的サイトジェネレーション) における開発標準とベストプラクティス（TypeScript対応）"
---

# Svelte/SvelteKit 開発ガイドライン (SSG対応)

SSG（静的サイトジェネレーション）を用いた高品質な Svelte/SvelteKit アプリケーションを構築するための標準とベストプラクティスです。

## プロジェクト概要 (Project Context)

- **フレームワーク**: SvelteKit v1 系 (内部で Svelte v4) を使用。

- **レンダリング方式**: 静的サイトジェネレーション (SSG) を基本とし、公式の `@sveltejs/adapter-static` を用いてサイト全体を静的ファイルとしてプリレンダリングします。これにより初回ロードはサーバーレンダリングされたHTMLを返し、以降のページ遷移はクライアント側で行うハイブリッド構成となります

- **TypeScript**: 型安全性と開発体験向上のため **TypeScript** を使用します。Svelte用VSCode拡張機能や `svelte-check` によりエディタ上でエラーを早期発見でき、ビルド前に不整合を防ぎます。

- **コンポーネント構造**: `.svelte` 単一ファイルコンポーネントでUIを構築。テンプレート、ロジック、スタイルを一箇所で管理し、コンポーネント指向の開発を行います。Svelteの宣言的リアクティブ構文を活用し、最小限のコードで双方向データバインディングや状態管理が可能です。

- **スタイル**: コンポーネント内のスコープドCSSを基本とし、必要に応じてSCSSなどのプリプロセッサを導入します（Vite統合により `lang="scss"` を指定するだけで利用可能）。グローバルデザイン指針は共通のレイアウトやスタイルシートにまとめ、全体の一貫性を保ちます。

## ファイル構成 (Project Structure)

プロジェクトは以下のような構成となります

```plaintext
front/
├── src/
│   ├── lib/                # 共通のコンポーネントやユーティリティを格納
│   │   ├── server/         # サーバー専用のライブラリ（クライアントには含まれない）
│   │   └── ...             # 汎用的な関数・コンポーネント類
│   ├── params/             # 動的ルート用のパラメータマッチャ
│   ├── routes/             # ページコンポーネントとルーティング定義
│   │   └── ...             # 各ルート（ページ）に対応するディレクトリ
│   ├── app.html            # アプリのHTMLテンプレート
│   ├── error.html          # フォールバック用エラーページ
│   ├── hooks.client.ts     # クライアントサイドのフック（省略可）
│   ├── hooks.server.ts     # サーバーサイドのフック（省略可）
│   └── service-worker.js   # サービスワーカー（必要な場合のみ）
├── static/                 # 静的アセット（ビルド出力にそのまま含まれる）
├── tests/                  # テストコード（Vitest や Playwright）
├── svelte.config.js        # SvelteKit の設定ファイル
├── tsconfig.json           # TypeScript コンパイル設定
└── vite.config.js          # Vite ビルドツールの設定
```

上記のように、SvelteKit プロジェクトは規約に沿ったファイル/フォルダ構成を持ちます

主要なディレクトリとファイルの概要:

- **`src/lib/`**: アプリ全体で使う再利用可能なコード (ユーティリティ関数、共通コンポーネントなど) を格納します。ここに置いたモジュールは `$lib` エイリアスでインポート可能です。また `lib/server/` 配下に置いたものはクライアント側バンドルに含まれずサーバー専用コードとして利用できます

- **`src/routes/`**: アプリケーションの各ページ (ルート) を格納します。ディレクトリ構造がそのままURLパスに対応し、各フォルダ内の `+page.svelte` がページ本体のコンポーネントとなります。単一のルートでしか使われないコンポーネントは、そのルートディレクトリ内に配置しても構いません。

- **`src/app.html`**: ページの土台となるHTMLテンプレートです。`<head>` や `<body>` 内にSvelteKitが自動注入するプレースホルダー `%sveltekit.head%` や `%sveltekit.body%` を含んでおり、必要に応じてカスタムMETAやスクリプトを挿入します。

- **`static/`**: ビルド結果にそのままコピーされる静的ファイル置き場です。画像やフォント、faviconなど、アプリで参照する静的リソースを配置します。これらはビルド後、最終的なサイトでも `/` パス直下のファイルとして提供されます。

- **`hooks.client.ts` / `hooks.server.ts`**: グローバルなフック処理を記述します。たとえばリクエスト共通処理やセッション管理、エラーハンドリング等をここで実装すると、全ページに共通の挙動を差し込めます。

- **`tests/`**: テストコードを配置するディレクトリです。ユニットテスト（Vitest）やE2Eテスト（Playwright）を管理します。

- **設定ファイル**: `svelte.config.js` や `tsconfig.json` はビルドや開発サーバの設定用ファイルです。プロジェクト作成時のオプションによっては、`.eslintrc` や `.prettierrc` などの設定ファイルも含まれます。

## ルーティング (Routing)

SvelteKitでは、ファイルシステムに基づく自動ルーティングが採用されています。`src/routes` フォルダ以下の構造がそのままURL構造になります。

主なルーティング規則:

- **ページルート**: 各フォルダ直下の `+page.svelte` コンポーネントがページを表します。そのフォルダ名がURLのパスになります。例として、`src/routes/about/+page.svelte` は `/about` パスに対応したページになります。

- **インデックスルート**: `src/routes/+page.svelte` はルートパス(`/`)に対応するページです。いわゆるサイトのホームページに相当します。

- **動的ルート**: 角括弧で囲んだフォルダ名は動的パラメータを表します。例えば `src/routes/blog/[slug]/+page.svelte` とすれば、`/blog/任意の文字列` にマッチし、その部分が `slug` パラメータとして扱われます。ページ内やロード関数では `params.slug` として利用できます。

- **レイアウト**: 複数のページに共通するレイアウトや処理は、共通の親ディレクトリに `+layout.svelte` を配置することで実現します。そのディレクトリ配下の全ページはレイアウトコンポーネントでラップされて表示されます。また、レイアウトごとに `+layout.js` (または `.server.js`) を用意し、共通データを取得する `load` 関数を定義することも可能です。

- **ハイブリッドレンダリング**: 基本的に全ページを静的化しますが、どうしても動的処理が必要な場合は、特定のページのみプリレンダリングを無効化してサーバーサイドレンダリング(SSR)を併用することもできます。ただしSSGサイトではランタイムのサーバーが存在しないため、外部のAPIサービスやサーバーレス関数を利用する構成が多く、可能な限りビルド時にデータを取り込む設計を心がけてください。

## データ取得 (Data Loading)

各ページの表示前に必要なデータを取得する場合、**ロード関数(load)** を利用します。ページやレイアウトに対応する `+page.js`/`+layout.js`（TypeScriptの場合 `.ts`）ファイルに `load` 関数を定義すると、SvelteKit はレンダリング前にその関数を実行し、返却値をページコンポーネントに渡します。

主なポイント:

- **ページごとのロード関数**: ページコンポーネントに対応する `+page.js` ファイルで `export const load = async (...) => { ... }` を定義できます。`load` 関数がオブジェクトを返すと、その中身がページ側では `export let data` 経由で参照可能になります。例えば以下のコードは投稿一覧データを取得してページに渡す例です:

  ```js
  // src/routes/posts/+page.ts
  export const load = async ({ fetch }) => {
    const res = await fetch('https://jsonplaceholder.typicode.com/posts?_limit=10');
    const posts = await res.json();
    return { posts };
  };
  ```

  上記では外部APIから投稿リストを取得し、戻り値として `{ posts }` を返しています。対応するページコンポーネントでは、受け取った `data.posts` を使って投稿を一覧表示できます。

- **型安全なデータ受け渡し**: SvelteKitでは各ルートごとに型定義ファイル(`$types.d.ts`)が自動生成され、対応する `PageData` 型や `PageLoad` 関数の型が用意されます。これにより、`load` 関数の戻り値とページコンポーネント上の `data` オブジェクトの型が一致し、TypeScriptで厳密にチェックされます。開発者は推論された型に従って実装するだけで、ページとロード関数のデータ受け渡しにおける不整合を防げます。

- **ビルド時データと動的データ**: 静的サイトとして全ページをプリレンダリングする際、`load` 関数で取得したデータはビルド時に取り込まれます。そのため、ビルド後にデータが変化してもサイトには反映されません。更新頻度の高いデータを扱う場合は、ビルド毎に最新を取り込むか、クライアント側で `onMount` 後に fetch するなどの戦略が必要です。ページ数が非常に多い場合はビルド時間が長くなるため、**Incremental Static Regeneration (ISR)** のような仕組みも検討します。

## 状態管理 (State Management)

複数コンポーネント間で共有する状態は、**ストア(store)** や **コンテキスト(context)** の機能を利用して管理します。小規模な状態共有には親子間のプロパティ受け渡しやイベントで十分ですが、幅広いコンポーネントからアクセスする必要があるデータにはストアを使うと便利です。

- **ストアの利用**: Svelteは公式にリアクティブストア機能を提供しています。`svelte/store` モジュールから `writable`, `readable`, `derived` といった関数を使ってストアを作成できます。生成したストアはコンポーネント内で `$storeName` と書くだけで値をリアクティブに参照可能です。ストアはグローバルなシングルトンとして作用するため、グローバル状態管理に適しており、Reduxのような外部状態管理ライブラリを導入しなくても十分対応できます。

- **コンテキストの活用**: コンポーネントツリーの深い階層にデータや関数を渡す場合、`setContext` と `getContext` が利用できます。これにより、明示的なprops引き回し（prop drilling）をせずに祖先コンポーネントから子孫コンポーネントへ値を共有できます。アプリ全域で使う設定値やシングルトンなサービスオブジェクトを提供する際に有用です。

## コンポーネント開発と再利用 (Components & Reusability)

SvelteのコンポーネントはHTMLとスクリプト、スタイルをひとつにカプセル化した再利用可能な単位です。適切にコンポーネントを設計し、DRY原則（繰り返しの排除）に沿って開発することで、保守性が向上します。

- **命名と配置**: 再利用可能なUI部品は `src/lib/` 配下に配置し、コンポーネントのファイル名およびタグ名はパスカルケース（例: `NavBar.svelte`, `<NavBar>`）で記述します。一方、特定のページでのみ使うコンポーネントはそのページの `routes/` サブフォルダ内に収め、他から参照しないようにします。こうすることで共有コンポーネントとページ固有コンポーネントの責務が分離され、フォルダ構成で意図が明確になります。

- **データの受け渡し**: コンポーネント間のデータ受け渡しは **propsとイベント** を用いるのが原則です。親→子方向は子コンポーネント側で `export let プロパティ名;` を宣言し、親から属性として値を渡します。子→親方向は `createEventDispatcher` によるカスタムイベント送出で親コンポーネントが受け取ります。複数階層をまたぐデータ共有が必要な場合は前述のストアやコンテキストを利用し、コンポーネント間の結合度を下げます。

- **ライフサイクル**: Svelteコンポーネントには `onMount`, `onDestroy` などのライフサイクルフックがあります。**`onMount` はクライアント側でのみ実行**され（SSR時やビルド時には実行されません）、DOM操作やブラウザAPIの利用はこの中で行う必要があります。例えば、`window` や `document` へのアクセスを含む処理は必ず `onMount` 内に記述し、静的プリレンダリング時にはスキップされるようにします。逆に、API呼び出しなどビルド時にも実行したい処理はロード関数に入れるべきです。

- **アクセシビリティ**: UI部品を作成する際はアクセシビリティにも配慮します。適切なセマンティックHTML要素の使用や必要なARIA属性の付与に努め、キーボード操作への対応も確認します。Svelteはフレームワークとして特別なアクセシビリティ警告機能はありませんが、一般的なWeb標準に従う限りアクセシブルなアプリを構築できます。手動で焦点制御を行う場合なども、標準APIを使い正しく実装してください。

## スタイルとデザイン (Styling & UI)

スタイリングはコンポーネント内のスコープドCSSを基本としつつ、全体のデザイン調整やテーマ適用には適宜グローバルスタイルも使用します。

- **コンポーネント毎のスタイル**: `<style>` ブロックに記述したCSSは、そのコンポーネント要素にのみ適用されます。異なるコンポーネント間で同名のクラスがあっても干渉しないため、コンポーネントごとに独立したスタイル定義が可能です。スタイルはデフォルトでscopedですが、特定のセレクタに対してグローバルに当てたい場合は次項のとおり対応します。

- **グローバルスタイル**: アプリ全体に影響するスタイルはグローバルスタイルとして定義します。方法は2通りあります。(1) **`:global` 指定**: コンポーネントの `<style>` 内で `:global(...)` 修飾子を使うと、そのセレクタに対するスタイルがグローバルに適用されます。例えば `<style>:global(body) { margin: 0; }</style>` と書けば全ページの `<body>` にマージン0を適用できます。(2) **レイアウトで一括定義**: ルートレイアウトコンポーネント（例: `src/routes/+layout.svelte`）でグローバルスタイル用のCSSをインポートする方法です。デフォルトのプロジェクトテンプレートでも `+layout.svelte` 内で `import '../app.css';` により全体スタイルを読み込んでいます。必要に応じてこのファイルを編集するか、独自のグローバルCSS/SCSSファイルを作成して読み込ませることでサイト全体の共通スタイルを提供します。

- **プリプロセッサの利用**: SvelteKitはビルドツールにViteを用いているため、追加設定なしでSCSSなどのプリプロセッサが利用可能です。各コンポーネントの `<style lang="scss">` にSCSSを記述すれば、ネスト記法や変数などが使えて便利です。また、プロジェクト全体のグローバルスタイルをSCSSで管理したい場合は、公式拡張ツール（例えば `svelte-add`）を用いてプリプロセス設定を追加できます。

- **CSSフレームワーク**: 必要に応じてTailwind CSS等のCSSフレームワークを導入しても構いません。ただし生成された静的ファイルサイズを抑えるため、未使用CSSのパージ設定や開発ビルドと本番ビルドの挙動に注意します。SvelteKitプロジェクトでもPostCSSプラグインやTailwindの設定を組み込むことが可能であり、デザインシステムに沿った効率的な開発が行えます。

## テストと品質管理 (Testing & Quality)

開発したアプリケーションの品質を維持するため、自動テストやリントを導入します。SvelteKitプロジェクトは設定次第で以下のツールを統合できます。

- **リンティング & フォーマット**: コードスタイル統一とバグ予防のため、ESLint（静的解析）と Prettier（自動整形）を利用します。プロジェクト作成時に設定を選択していれば、`.eslintrc` や `.prettierrc` が用意されています。エディタにプラグインを入れて保存時にフォーマットを実行することで、常に一貫したコードスタイルを保ちます。

- **型チェック**: TypeScriptによる型チェックは強力なバグ防止策です。`svelte-check` コマンドをCIに組み込み、型エラーやSvelte特有のエラーを検出します。VSCodeのSvelte拡張と組み合わせれば、開発中から型の不一致に気づけます。

- **単体テスト**: コンポーネントや関数単位のテストにはVitestなどのフレームワークを使用できます。`create-svelte` テンプレートでテスト導入を選択した場合、`src` 配下に `*.test.ts` ファイルを配置してテストを記述できます。Svelteコンポーネントのユニットテストには公式の https://github.com/testing-library/svelte-testing-library などを用いて、入力（props）と出力（DOM変化やイベント）を検証します。
